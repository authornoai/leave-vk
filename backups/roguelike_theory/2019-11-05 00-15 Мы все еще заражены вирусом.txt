# Мы все еще заражены вирусом...

Мы все еще заражены вирусом императивного программирования, которое заставляет нас постоянно различать код и переменные. Даже если код меняет сам себя, то все равно в любой момент есть кусок кода, который выполняется, а есть тот, который меняют. Как только различие между кодом и переменными проведено, сразу же начинаются и попытки их перестать различать. У Малабу это, например, "нейропластичность", понятие, которое точно указывает на проблему, но не говорит ничего о ее разрешении (“нейропластичность — это когда мозг меняет сам себя”). 
 
Проблема с этим различием в том, что оно предполагает, что есть какой-то субъект, который код читает и выполняет (для компьютера это процессор или интерпретатор), и что он играет по правилам. "Код" всегда пишется для кого-то другого, это инструкция, в одинаковой мере выражающая суть вычисления и подстраивающаяся под особенности этого другого. Задача людей, которые пытаются обратно поженить код и переменные, заключается в том, чтобы одновременно и сохранить на каком-то уровне правила выполнения кода — например, правила чтения ДНК или чего-то еще — но и избавиться от их незыблемости; одновременно уважительно указать на Большого Другого и сказать, что он не существует. В итоге получается довольно вялая с точки зрения концептов, но полная истеричной романтики в гегельянском духе философия. И все это из-за того, что мы, при нашей любви к вычислению как метафоре всего во вселенной, ограниченно воспринимаем вычисление на примерах плохих и некрасивых языков программирования. 
 
Посмотрим же лучше на замечательный язык программирования Haskell. Он на этом различии просто-напросто не настаивает (хотя вполне умеет работать и с ним). Вычисление, описываемое им, не происходит по каким-то определенным последовательным шагам: оно описано в виде законченной формулы, выражающей ответ непосредственно, а не просто обещающей прийти к ответу, если выполнять инструкции. (Сумма чисел на Haskell будет описана как "сумма чисел", а не как "возьми первое число, прибавь второе, потом третье"…) Вычисление на этом языке не движется по конкретным шагам в четкой последовательности, но медленно уточняется по мере надобности. Если попросить Haskell дать нам список простых чисел, он не побежит их все вычислять одно за другим, но лениво скажет: ну вот тебе какой-то список; теперь мы спросим: так, ну и какое из них второе по счету? Только тогда он полезет вычислять и сообщит, что "три". Информация, которой пока еще нет применения, не вычисляется Хаскелем, но сохраняется в недовычисленном виде, всегда готовом для того, чтобы его довычислить, если нужно, конечно. Поэтому Хаскель может спокойно описывать даже бесконечное — просто как нечто такое, что всегда можно по мере надобности вычислить еще на шажок вперед. 
 
Одно из редких для философии полезных свойств Хаскеля заключается в том, что он вполне существует и работает, а значит, из того, как он устроен, мы можем взять какое-то другое концептуальное понимание вычисления, не настаивающее на вышеупомянутом различии кода и переменных, которое только создает проблемы. Под капотом у Хаскеля вычисление, которое подвешено в невычисленном, но готовом к вычислению состоянии, сохраняется с помощью структуры под названием Thunk. Thunk — это как коробка с тортом, которая станет готовить торт только тогда, когда ее откроют. Коробка Шрёдингера — это Thunk. Слишком простое домашнее задание — это Thunk. (Я не знаю, как перевести Thunk, поэтому здесь слово "Thunk" — это Thunk русского перевода слова Thunk.) 
 
При этом в программе на языке Haskell нет никаких явных указаний на эти Thunk. Программа может думать, что она сама полностью уже вычислена (и поэтому даже способна рекурсивно обращаться к себе самым наглым способом: бесконечная последовательность всех натуральных чисел это "1, а потом вся сама эта последовательность, только ко всему прибавлено 1" - уточненное на один шаг это будет “1, 1 + 1, а потом вся сама эта последовательность, только ко всему дважды прибавлено 1”). А это значит, что она в принципе не воспринимает сама себя как процесс, в ней нет никакой наперед заданной последовательности, ей нет смысла "модифицировать свой код". Так же и с мыслями: часто мысль в голове выглядит, как уже полностью понятая, и только по мере ее, например, записи, наталкиваешься на моменты, которые надо уточнить или переформулировать. Эти моменты по мере их медленного уточнения не просто добавляют пару слов, но могут переписать (или упростить) целые куски получающегося текста, а иногда и своей ошибочностью заставить его весь выкинуть на помойку. 
 
Вычисление, понятое таким образом, — процесс медленного уточнения формулы, которая не воспринимает саму себя как процесс, но лишь как тавтологию. Эта гегельянская на вид фраза не является чистой спекуляцией, но описанием существующего и хорошо понятного языка программирования. Более того: такого рода уточняемая формула не требует даже единства и понятности уточняющего ее "субъекта-интерпретатора": разные ее части в принципе могут уточняться разными процессами и разными способами; ее можно легко недовычислить, сохранить, отдать на довычисление потомкам.

![](attachments/457239109.jpg)

Date: 2019-11-05 00:15
Likes: 60
Comments: 1
Reposts: 11
Views: 2858
Original URL: https://vk.com/wall-140963346_363

